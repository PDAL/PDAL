
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDAL Architecture Overview &mdash; pdal.io</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/pdal.css" type="text/css" />
      <link rel="stylesheet" href="../_static/breathe.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="canonical" href="https://pdal.io/development/overview.html"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Compilation" href="compilation/index.html" />
    <link rel="prev" title="Development" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
          </a>
              <div class="version">
                2.6.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../download.html">Download</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quickstart</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../apps/index.html">Applications</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../community.html">Community</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pipeline.html">Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stages/stages.html">Stages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stages/readers.html">Readers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stages/writers.html">Writers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stages/filters.html">Filters</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dimensions.html">Dimensions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../types.html">Types</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../python.html">Python</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../java.html">Java</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorials</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../workshop/index.html">Workshop</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Development</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">PDAL Architecture Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-pdal-model">The PDAL model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#extending-pdal">Extending PDAL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#making-a-stage-reader-filter-or-writer">Making a Stage (Reader, Filter or Writer):</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-a-reader">Implementing a Reader</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-a-filter">Implementing a Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-a-writer">Implementing a Writer:</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="compilation/index.html">Compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="errorhandling.html">Errors and Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="metadata.html">Metadata</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing.html">Writing with PDAL</a></li>
<li class="toctree-l2"><a class="reference internal" href="plugins.html">Writing and building a PDAL Plugin</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing-filter.html">Writing a filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing-kernel.html">Writing a kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing-reader.html">Writing a reader</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing-writer.html">Writing a writer</a></li>
<li class="toctree-l2"><a class="reference internal" href="cmake.html">CMake</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../project/index.html">Project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../copyright.html">License</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../references.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PDAL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html"> Documentation </a> &raquo;</li>
      
          <li><a href="index.html">Development</a> &raquo;</li>
      
      <li>PDAL Architecture Overview</li>
    

    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/PDAL/PDAL/edit//master/doc/development/overview.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="compilation/index.html" class="btn btn-neutral float-right" title="Compilation" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Development" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pdal-architecture-overview">
<span id="overview"></span><h1>PDAL Architecture Overview<a class="headerlink" href="#pdal-architecture-overview" title="Permalink to this heading"></a></h1>
<dl class="field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Andrew Bell</p>
</dd>
<dt class="field-even">Contact<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="mailto:andrew&#37;&#52;&#48;hobu&#46;co">andrew<span>&#64;</span>hobu<span>&#46;</span>co</a></p>
</dd>
<dt class="field-odd">Date<span class="colon">:</span></dt>
<dd class="field-odd"><p>5/15/2016</p>
</dd>
</dl>
<p>PDAL is a set of applications and library to facilitate translation of point
cloud data between various formats.  In addition, it provides some facilities
for transformation of data between various geometric projections
and can calculate some statistical, boundary and density data.  PDAL also
provides point classification algorithms.
PDAL provides an API that can be used by programmers for integration into their
own projects or to allow extension of existing capabilities.</p>
<section id="the-pdal-model">
<span id="id1"></span><h2>The PDAL model<a class="headerlink" href="#the-pdal-model" title="Permalink to this heading"></a></h2>
<p>PDAL reads data from a set of input sources using format-specific readers.
Point data can be passed through various filters that transform data or create
metadata.  If desired, points can be written to an output stream using a
format-specific writer.  PDAL can merge data from various input sources into a
single output source, preserving attribute data where supported by the input
and output formats.</p>
<img alt="../_images/pipeline.png" src="../_images/pipeline.png" />
<p>The above diagram shows a possible arrangement of PDAL readers, filters and
writers, all of which are known as stages.  Any merge operation or filter
may be
placed after any reader.  Output filters are distinct from other filters only in
that they may create more than one set of points to be further filtered or
written.  The arrangement of readers, filters and writers is called a PDAL
pipeline.  Pipelines can be specified using JSON as detailed later.</p>
<section id="extending-pdal">
<h3>Extending PDAL<a class="headerlink" href="#extending-pdal" title="Permalink to this heading"></a></h3>
<p>PDAL is simple to extend by implementing subclasses of existing stages.  All
processing in PDAL is completely synchronous.  No parallel processing occurs,
eliminating locking or other concurrency issues.  Understanding of several
auxiliary classes is necessary to effectively create a new stage.</p>
<section id="dimension">
<h4>Dimension<a class="headerlink" href="#dimension" title="Permalink to this heading"></a></h4>
<p>Point cloud formats support various data elements.  In order to be useful, all
formats must provide some notion of location for points (X, Y and perhaps Z),
but beyond that, the data collected in formats may or may not have common data
fields.  Some formats predefine the elements that make up a point.  Other
formats provide this information in a header or preamble.  PDAL calls each of
the elements that make up a point a dimension.  PDAL predefines the dimensions
that are in common use by the formats that it currently supports.  Readers may
register their use of a predefined dimension or may have PDAL create a
dimension with a name and type as requested.  Dimensions are described in a
JSON file, Dimension.json.</p>
<p>PDAL has a default type (Double, Float, Signed32, etc.) for each of its
predefined dimensions which is believed to be sufficient to accurately
hold the necessary data.  Only when the default data type is deemed
insufficient should a request be made to “upgrade” a storage datatype.  There
is no simple facility to “downsize” a dimension type to save memory, though
it can be done by creating a custom PointLayout object.  Dimension.json
can be examined to determine the default storage type of each predefined
dimension.  In most cases knowledge of the storage data type for
a dimension isn’t required.  PDAL properly converts data to and from the
internal storage type transparently.  Invalid conversions raise an exception.</p>
<p>When a storage type is explicitly requested for a dimension, PDAL examines the
existing storage type and requested type and chooses the storage type so
that it can hold both types.  In some cases this results in a storage type
different from either the existing or requested storage type.  For instance,
if the current storage type is a 16 bit signed integer (Signed16) and the
requested type is a 16 bit unsigned integer (Unsigned16), PDAL will use a
32 bit signed integer as the storage type for the dimension so that both
16 bit storage types can be successfully accommodated.</p>
</section>
<section id="point-layout">
<h4>Point Layout<a class="headerlink" href="#point-layout" title="Permalink to this heading"></a></h4>
<p>PDAL stores the dimension information in a point layout structure
(PointLayout object).  It stores information about the physical layout of
data of each point in memory and also stores the type and name of each
dimension.</p>
</section>
<section id="point-table">
<h4>Point Table<a class="headerlink" href="#point-table" title="Permalink to this heading"></a></h4>
<p>PDAL stores points in what is called a point table (PointTable object).  Each
point table has an associated point layout describing its format.  All
points in a single point table have the same dimensions and all operations on
a PDAL pipeline make use of a single point table.  In addition to storing
points, a point table also stores pipeline metadata that may be created as
pipeline stages are executed.  Most functions receive a PointTableRef object,
which refers to the active point table.  A PointTableRef can be stored
or copied cheaply.</p>
<p>A subclass of PointTable called StreamingPointTable exists to allow a pipeline
to run without loading all points in memory.  A StreamingPointTable holds a
fixed number of points.  Some filters can’t operate in streaming mode and
an attempt to run a pipeline with a stage that doesn’t support streaming
will raise an exception.</p>
</section>
<section id="point-view">
<h4>Point View<a class="headerlink" href="#point-view" title="Permalink to this heading"></a></h4>
<p>A point view (PointView object) stores references to points.  Storage
and retrieval of points is done through a point view rather than directly
through a point table.  Point data is accessed from a point view through a
point ID (type PointId), which is an integer value.  The first point reference
in a point view has a point ID of 0, the second has a point ID of 1, the third
has a point ID of 2 and so on.  There are no null point references in a point
view.  The size of a point view is the number of point references contained
in the view.  A point view acts like a self-expanding array or vector of
point references, but it is always full.  For example, one can’t set the field
value of point with a PointId of 9 unless there already exist at least 8 point
references in the point view.</p>
<p>Point references can be copied from one point view to another by appending an
existing reference to a destination point view. The point ID of the appended
point in the destination view may be different than the point ID of the same
point in the source view.  The point ID of an appended point reference is the
same as the size of the point view after the operation.  Note that appending a
point reference does not create a new point.  Rather, it creates another
reference to an existing point.  There are currently no built-in facilities for
creating copies of points.</p>
</section>
<section id="point-reference">
<h4>Point Reference<a class="headerlink" href="#point-reference" title="Permalink to this heading"></a></h4>
<p>Some functions take a reference to a single point (PointRef object).
In streaming mode, stages implement the processOne() function which operates
on a point reference instead of a point view.</p>
</section>
</section>
<section id="making-a-stage-reader-filter-or-writer">
<h3>Making a Stage (Reader, Filter or Writer):<a class="headerlink" href="#making-a-stage-reader-filter-or-writer" title="Permalink to this heading"></a></h3>
<p>All stages (Stage object) share a common interface, though readers, filters and
writers each have a simplified interface if the generic stage interface is more
complex than necessary.  One should create a new stage by creating a subclass of
reader (Reader object), filter (Filter object) or writer (Writer
object).  When a pipeline is made, each stage is created using its default
constructor.</p>
<p>When a pipeline is started, each of its stages is processed in two distinct
steps.  First, all stages are prepared.</p>
<section id="stage-preparation">
<h4>Stage Preparation<a class="headerlink" href="#stage-preparation" title="Permalink to this heading"></a></h4>
<p>Preparation of a stage is done by calling the prepare() function of the stage
at the end of the pipeline.  prepare() executes the following private virtual
functions calls, none of which need to be implemented in a stage unless desired.
Each stage is guaranteed to be prepared after all stages that precede it in the
pipeline.</p>
<ol class="arabic">
<li><p>void addArgs(ProgramArgs&amp; args)</p>
<blockquote>
<div><p>Stages can accept various options to control processing.  These options
can be declared and bound to variables in this function.  When arguments
are added, the stage also provides a description and optionally a default
value for the argument.</p>
</div></blockquote>
</li>
<li><p>void initialize() OR void initialize(PointTableRef)</p>
<blockquote>
<div><p>Some stages, particularly readers, may need to do things such as open files
to extract header information before the next step in processing.  Other
general processing that needs to take place before any stage is executed
should occur at this time.  If the initialization requires knowledge of
the point table, implement the function that accepts one, otherwise
implement the no-argument version.  Whether to place initialization code
at this step or in prepared() or ready() (see below) is a judgment call,
but detection of errors earlier in the process allows faster termination of
a command.  Files opened in this step should also be closed before
returning.</p>
</div></blockquote>
</li>
<li><p>void addDimensions(PointLayoutPtr layout)</p>
<blockquote>
<div><p>This method allows stages to inform a point table’s layout of the dimensions
that it would like as part of the record of each point.  Usually, only
readers add dimensions to a point table, but there is no prohibition on
filters or writers from adding dimensions if necessary.  Dimensions should
not be added to the layout outside of this method.</p>
</div></blockquote>
</li>
<li><p>void prepared(PointTableRef)</p>
<blockquote>
<div><p>Called after dimensions are added.  It can be used to verify state and
raise exceptions before stage execution.</p>
</div></blockquote>
</li>
</ol>
</section>
<section id="stage-execution">
<h4>Stage Execution<a class="headerlink" href="#stage-execution" title="Permalink to this heading"></a></h4>
<p>After all stages are prepared, processing continues with the execution of each
stage by calling execute().  Each stage will be executed only after all stages
preceding it in a pipeline have been executed.  A stage is executed by
invoking the following private virtual methods.  It is important to note
that ready() and done() are called only once for each stage while run()
is called once for each point view to be processed by the stage.</p>
<ol class="arabic">
<li><p>void ready(PointTablePtr table)</p>
<blockquote>
<div><p>This function allows preprocessing to be performed prior to actual
processing of the points in a point view.  For example, filters may
initialize internal data structures or libraries, readers may connect to
databases and writers may write a file header.  If there is a choice between
performing operations in the preparation stage (in the initialize() method)
or the execution stage (in ready()), prefer to defer the operation until
this point.</p>
</div></blockquote>
</li>
<li><p>PointViewSet run(PointViewPtr buf)</p>
<blockquote>
<div><p>This is the method in which processing of individual points occurs.  One
might read points into the view, transform point values in some way, or
distribute the point references in the input view into numerous output
views.  This method is called once for each point view passed to the
stage.</p>
</div></blockquote>
</li>
<li><p>void done(PointTablePtr table)</p>
<blockquote>
<div><p>This function allows a stage to clean up resources not released by a
stage’s destructor.  It also allows other execution of termination
functions, such a closing of databases, writing file footers,
rewriting headers or closing or renaming files.</p>
</div></blockquote>
</li>
</ol>
</section>
<section id="streaming-stage-execution">
<h4>Streaming Stage Execution<a class="headerlink" href="#streaming-stage-execution" title="Permalink to this heading"></a></h4>
<p>PDAL normally processes all points through each stage before passing the
points to the next stage.  This means that all point data is held in memory
during processing.  There are some situations that may make this undesirable.
As an alternative, PDAL allows execution of data with a point table that
contains a fixed number of points (StreamPointTable).  When a StreamPointTable
is passed to the execute() function, the private run() function detailed above
isn’t called, and instead processOne() is called for each point.  If a
StreamPointTable is passed to execute() but a pipeline stage doesn’t
implement processOne(), an exception is thrown.</p>
<p>bool processOne(PointRef&amp; ref)</p>
<blockquote>
<div><p>This method allows processing of a single point.  A reader will typically
read a point from an input source.  When a reader returns ‘false’ from
this function, it indicates that there are no more points to be read.
When a filter returns ‘false’ from this function, it indicates
that the point just processed should be filtered out and not passed
to subsequent stages for processing.</p>
</div></blockquote>
</section>
</section>
<section id="implementing-a-reader">
<h3>Implementing a Reader<a class="headerlink" href="#implementing-a-reader" title="Permalink to this heading"></a></h3>
<p>A reader is a stage that takes input from a point cloud format supported by
PDAL and loads points into a point table through a point view.</p>
<p>A reader needs to register or assign those dimensions that it will reference
when adding point data to the point table.  Dimensions that are predefined
in PDAL can be registered by using the point table’s registerDim()
method.  Dimensions that are not predefined can be added using assignDim().
If dimensions are determined as named entities from a point cloud source,
it may not be known whether the dimensions are predefined or not.  In this
case the function registerOrAssignDim() can be used.  When a dimension is
assigned, rather than registered, the reader needs to inform PDAL of the
type of the variable using the enumeration Dimension::Type.</p>
<p>In this example, the reader informs the point table’s layout that it will
reference the dimensions X, Y and Z.</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Reader</span><span class="p">::</span><span class="n">addDimensions</span><span class="p">(</span><span class="n">PointLayoutPtr</span> <span class="n">layout</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">layout</span><span class="o">-&gt;</span><span class="n">registerDim</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">X</span><span class="p">);</span>
   <span class="n">layout</span><span class="o">-&gt;</span><span class="n">registerDim</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Y</span><span class="p">);</span>
   <span class="n">layout</span><span class="o">-&gt;</span><span class="n">registerDim</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Z</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Here a reader determines dimensions from an input source and registers or
assigns them.  All of the input dimension values are in this case double
precision floating point.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Reader</span><span class="p">::</span><span class="n">addDimensions</span><span class="p">(</span><span class="n">PointLayoutPtr</span> <span class="n">layout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">FileHeader</span> <span class="n">header</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">di</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">di</span> <span class="o">!=</span> <span class="n">header</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">di</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">dimName</span> <span class="o">=</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
        <span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span> <span class="nb">id</span> <span class="o">=</span> <span class="n">layout</span><span class="o">-&gt;</span><span class="n">registerOrAssignDim</span><span class="p">(</span><span class="n">dimName</span><span class="p">,</span>
            <span class="n">Dimension</span><span class="p">::</span><span class="n">Type</span><span class="p">::</span><span class="n">Double</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If a reader implements initialize() and opens a source file during the function,
the file should be closed again before exiting the function to ensure that
file handles aren’t exhausted when processing a large number of files.</p>
<p>Readers should use the ready() function to reset the input data to a state
where the first point can be read from the source.  The done() function
should be used to free resources or reset the state initialized in ready().</p>
<p>Readers should implement a function, read(), that will place the data from
the input source into the provided point view:</p>
<p>point_count_t read(PointViewPtr view, point_count_t count)</p>
<blockquote>
<div><p>The reader should read at most ‘count’ points from the input source and
place them in the view.  The reader must keep track of its current
position in the input source and points should be read until no points
remain or ‘count’ points have been added to the view.  The current
location in the input source is typically tracked with a integer variable
called the index.</p>
<p>As each point is read from the input source, it must be placed at the end
of the point view.  The ID of the end of the point view can be
determined by calling size() function of the point view.  read() should
return the number of points read by during the function call.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">point_count_t</span> <span class="n">MyFormat</span><span class="p">::</span><span class="n">read</span><span class="p">(</span><span class="n">PointViewPtr</span> <span class="n">view</span><span class="p">,</span> <span class="n">point_count_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Determine</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">points</span> <span class="n">remaining</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">input</span><span class="o">.</span>
    <span class="n">point_count_t</span> <span class="n">remainingInput</span> <span class="o">=</span> <span class="n">m_totalNumPts</span> <span class="o">-</span> <span class="n">m_index</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Determine</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">points</span> <span class="n">to</span> <span class="n">read</span><span class="o">.</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">remainingInput</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">Determine</span> <span class="n">the</span> <span class="n">ID</span> <span class="n">of</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">point</span> <span class="n">view</span>
    <span class="n">PointId</span> <span class="n">nextId</span> <span class="o">=</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Determine</span> <span class="n">the</span> <span class="n">current</span> <span class="nb">input</span> <span class="n">position</span><span class="o">.</span>
    <span class="n">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">m_pointSize</span> <span class="o">*</span> <span class="n">m_index</span><span class="p">;</span>

    <span class="n">point_count_t</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">remaining</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>

        <span class="o">//</span> <span class="n">Read</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="ow">and</span> <span class="n">Z</span> <span class="kn">from</span> <span class="nn">input</span> <span class="n">source</span><span class="o">.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">m_file</span><span class="o">.</span><span class="n">read</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">);</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">m_file</span><span class="o">.</span><span class="n">read</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">);</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">m_file</span><span class="o">.</span><span class="n">read</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">);</span>

        <span class="o">//</span> <span class="n">Set</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="ow">and</span> <span class="n">Z</span> <span class="n">into</span> <span class="n">the</span> <span class="n">pointView</span><span class="o">.</span>
        <span class="n">view</span><span class="o">-&gt;</span><span class="n">setField</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">X</span><span class="p">,</span> <span class="n">nextId</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">view</span><span class="o">-&gt;</span><span class="n">setField</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Y</span><span class="p">,</span> <span class="n">nextId</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
        <span class="n">view</span><span class="o">-&gt;</span><span class="n">setField</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Z</span><span class="p">,</span> <span class="n">nextId</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>

        <span class="n">nextId</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">m_index</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that we don’t read more points than requested, we don’t read past
the end of the input stream and we keep track of our location in the
input so that subsequent calls to read() will result in all points being
read.</p>
<p>Here’s the same function written so that streaming can be supported:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">point_count_t</span> <span class="n">MyFormat</span><span class="p">::</span><span class="n">read</span><span class="p">(</span><span class="n">PointViewPtr</span> <span class="n">view</span><span class="p">,</span> <span class="n">point_count_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Determine</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">points</span> <span class="n">remaining</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">input</span><span class="o">.</span>
    <span class="n">point_count_t</span> <span class="n">remainingInput</span> <span class="o">=</span> <span class="n">m_totalNumPts</span> <span class="o">-</span> <span class="n">m_index</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Determine</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">points</span> <span class="n">to</span> <span class="n">read</span><span class="o">.</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">remainingInput</span><span class="p">);</span>

    <span class="o">//</span> <span class="n">Determine</span> <span class="n">the</span> <span class="n">ID</span> <span class="n">of</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">point</span> <span class="n">view</span>
    <span class="n">PointId</span> <span class="n">nextId</span> <span class="o">=</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Determine</span> <span class="n">the</span> <span class="n">current</span> <span class="nb">input</span> <span class="n">position</span><span class="o">.</span>
    <span class="n">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">m_pointSize</span> <span class="o">*</span> <span class="n">m_index</span><span class="p">;</span>

    <span class="n">point_count_t</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">remaining</span><span class="o">--</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PointRef</span> <span class="n">point</span><span class="p">(</span><span class="n">view</span><span class="o">-&gt;</span><span class="n">point</span><span class="p">(</span><span class="n">nextId</span><span class="p">));</span>

        <span class="n">processOne</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
        <span class="n">nextId</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">m_index</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">bool</span> <span class="n">MyFormat</span><span class="p">::</span><span class="n">processOne</span><span class="p">(</span><span class="n">PointRef</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Read</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="ow">and</span> <span class="n">Z</span> <span class="kn">from</span> <span class="nn">input</span> <span class="n">source</span><span class="o">.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">m_file</span><span class="o">.</span><span class="n">read</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
    <span class="n">pos</span> <span class="o">+=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">);</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">m_file</span><span class="o">.</span><span class="n">read</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
    <span class="n">pos</span> <span class="o">+=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">);</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">m_file</span><span class="o">.</span><span class="n">read</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
    <span class="n">pos</span> <span class="o">+=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">);</span>

    <span class="n">point</span><span class="o">.</span><span class="n">setField</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">X</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">point</span><span class="o">.</span><span class="n">setField</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Y</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">point</span><span class="o">.</span><span class="n">setField</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Z</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">m_file</span><span class="o">.</span><span class="n">ok</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="implementing-a-filter">
<span id="id2"></span><h3>Implementing a Filter<a class="headerlink" href="#implementing-a-filter" title="Permalink to this heading"></a></h3>
<p>A filter is a stage that allows processing of data after it has been read into a
pipeline’s point table.  In many filters, the only function that need be
implemented is filter(), a simplified version of the stage’s run() method whose
input and output is a point view provided by the previous stage:</p>
<p>void filter(PointViewPtr view)</p>
<blockquote>
<div><p>One should implement filter() instead of run() if its interface is
sufficient.  The expectation is that a filter will iterate through the
points currently in the point view and apply some transformation or gather
some data to be output as pipeline metadata.</p>
<p>Here as an example is the actual filter function from the reprojection
filter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">Reprojection</span><span class="p">::</span><span class="nb">filter</span><span class="p">(</span><span class="n">PointViewPtr</span> <span class="n">view</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">PointId</span> <span class="nb">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">id</span> <span class="o">&lt;</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="nb">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">X</span><span class="p">,</span> <span class="nb">id</span><span class="p">);</span>
        <span class="n">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Y</span><span class="p">,</span> <span class="nb">id</span><span class="p">);</span>
        <span class="n">double</span> <span class="n">z</span> <span class="o">=</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Z</span><span class="p">,</span> <span class="nb">id</span><span class="p">);</span>

        <span class="n">transform</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>

        <span class="n">view</span><span class="o">-&gt;</span><span class="n">setField</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">X</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">view</span><span class="o">-&gt;</span><span class="n">setField</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Y</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
        <span class="n">view</span><span class="o">-&gt;</span><span class="n">setField</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Z</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The filter simply loops through the points, retrieving the X, Y and Z
values of each point, transforms those value using a reprojection
algorithm and then stores the transformed values in the point table
using the point view’s setField() function.</p>
<p>A filter may need to use the run() function instead of filter(), typically
because it needs to create multiple output point views from a single input
view.  The following example puts every other input point into one of two
output point views:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>PointViewSet Alternator::run(PointViewPtr view)
{
    PointViewSet viewSet;
    PointViewPtr even = view();
    PointViewPtr odd = view();
    viewSet.insert(even);
    viewSet.insert(odd);
    for (PointId idx = 0; idx &lt; view-&gt;size(); ++idx)
    {
        PointViewPtr out = idx % 2 ? even : odd;
        out-&gt;appendPoint(*view.get(), idx);
    }
    return viewSet;
}
</pre></div>
</div>
</div></blockquote>
</section>
<section id="implementing-a-writer">
<h3>Implementing a Writer:<a class="headerlink" href="#implementing-a-writer" title="Permalink to this heading"></a></h3>
<p>Analogous to the filter() method in a filter is the write() method of a writer.
This function is usually the appropriate one to override when implementing
a writer – it would be unusual to need to implement run().  A
typical writer will open its output file when ready() is called, write
individual points in write() and close the file in done().</p>
<p>Like a filter, a writer may receive multiple point views during processing
of a pipeline.  This will result in the write() function being called once
for each of the input point views.  Writers may produce a separate output
file for each input point view or may produce a single output file.  The
documentation should clearly state this behavior.  Placing a merge filter
in front of a writer in the pipeline will make sure that a single point
view is passed to the writer.</p>
<p>As new writers are created, developers should try to make sure
that they behave reasonably if passed multiple point views – they
correctly handle write() being called multiple times after a single
call to ready().</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">write</span><span class="p">(</span><span class="n">const</span> <span class="n">PointViewPtr</span> <span class="n">view</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span> <span class="o">=</span> <span class="o">*</span><span class="n">m_out</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">PointId</span> <span class="nb">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">id</span> <span class="o">&lt;</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="nb">id</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">X</span><span class="p">,</span> <span class="nb">id</span><span class="p">);</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Y</span><span class="p">,</span> <span class="nb">id</span><span class="p">);</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Z</span><span class="p">,</span> <span class="nb">id</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">bool</span> <span class="n">processOne</span><span class="p">(</span><span class="n">PointRef</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">point</span><span class="o">.</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">X</span><span class="p">);</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">point</span><span class="o">.</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Y</span><span class="p">);</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">point</span><span class="o">.</span><span class="n">getFieldAs</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Dimension</span><span class="p">::</span><span class="n">Id</span><span class="p">::</span><span class="n">Z</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="compilation/index.html" class="btn btn-neutral float-right" title="Compilation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Development" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <div class="info">
      <a class="logo-link" href="https://hobu.co">
        <div class="hobu-logo"></div>
      </a>
      <div class="copyright">
      

                    &copy;  2023
                        <a href="https://github.com/abellgithub">Andrew Bell</a>,
                        <a href="https://github.com/chambbj">Brad Chambers</a>,
                        <a href="http://github.com/hobu">Howard Butler</a>,
                        and
                        <a href="https://github.com/PDAL/PDAL/graphs/contributors">others</a>.

      
      Last updated on May 22, 2023.
      </div>
    </div>
</footer>
        </div>
      </div>
    </section>
  </div>
  
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <div class="footer">
        <div class="container">
                    &copy;  2023
                        <a href="http://github.com/hobu">Howard Butler</a>,
                        <a href="http://github.com/mpgerlek">Michael Gerlek</a>,
                        and
                        <a href="https://github.com/PDAL/PDAL/graphs/contributors">others</a>,
                Last updated
                    on May 22, 2023.
        </div>
    </div>

</body>
</html>